/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

export class haxe_io_Bytes {
	protected constructor(data: ArrayBuffer);
	readonly length: number;
	/**
	 * Copies `len` bytes from `src` into this instance.
	 * @param pos Zero-based location in `this` instance at which to start writing
	 * bytes.
	 * @param src Source `Bytes` instance from which to copy bytes.
	 * @param srcpos Zero-based location at `src` from which bytes will be copied.
	 * @param len Number of bytes to be copied.
	 */
	blit(pos: number, src: haxe_io_Bytes, srcpos: number, len: number): void;
	/**
	 * Returns the `Bytes` representation of the given `BytesData`.
	 */
	static ofData(b: ArrayBuffer): haxe_io_Bytes;
}

export class haxe_io_BytesBuffer {
	constructor();
	addByte(byte: number): void;
	addInt32(v: number): void;
	addDouble(v: number): void;
	/**
	 * Returns either a copy or a reference of the current bytes.
	 * Once called, the buffer should no longer be used.
	 */
	getBytes(): haxe_io_Bytes;
}

export class haxe_io_BytesInput extends haxe_io_Input {
	constructor(b: haxe_io_Bytes, pos?: number, len?: number);
	readByte(): number;
}

export class console_NamespaceEntry {
	constructor(ns: console_Namespace, fname: string, ftype: any, minArgs: number, maxArgs: number, usage: string, pkg: string);
	namespace: console_Namespace;
	functionName: string;
	type: any;
	minArgs: number;
	maxArgs: number;
	usage: string;
	pkg: string;
}

export class console_Namespace {
	constructor(name: string, pkg: string, parent: console_Namespace);
	name: string;
	pkg: string;
	parent: console_Namespace;
	entries: console_NamespaceEntry[];
	addFunction(name: string, functionOffset: number, codeblock: CodeBlock): void;
	addFunctionFull(name: string, usage: string, minArgs: number, maxArgs: number, ftype: any): void;
	find(functionName: string): console_NamespaceEntry;
}

export class CodeBlock {
	constructor(vm: VM, fileName: string);
	addedFunctions: boolean;
	loadFromData(bytes: haxe_io_BytesBuffer): void;
	load(inData: haxe_io_BytesInput): void;
	exec(ip: number, functionName: string, namespace: console_Namespace, fnArgs: string[], noCalls: boolean, packageName: string): string;
}

export class StringTableEntry {
	constructor(s: string, start: number, len: number, tag: boolean);
	string: string;
	start: number;
	len: number;
	tag: boolean;
}

/**
 * An `Iterator` is a structure that permits iteration over elements of type `T`.
 * Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
 * and can then be used e.g. in `for`-loops. This makes it easy to implement
 * custom iterators.
 * @see https://haxe.org/manual/lf-iterators.html
 */
export type Iterator<T> = {
	/**
	 * Returns `false` if the iteration is complete, `true` otherwise.
	 * Usually iteration is considered to be complete if all elements of the
	 * underlying data structure were handled through calls to `next()`. However,
	 * in custom iterators any logic may be used to determine the completion
	 * state.
	 */
	hasNext(): boolean;
	/**
	 * Returns the current item of the `Iterator` and advances to the next one.
	 * This method is not required to check `hasNext()` first. A call to this
	 * method while `hasNext()` is `false` yields unspecified behavior.
	 * On the other hand, iterators should not require a call to `hasNext()`
	 * before the first call to `next()` if an element is available.
	 */
	next(): K;
}

export interface haxe_IMap<K, V> {
	get(k: K): V;
	keys(): Iterator<K>;
}

export class StringTable {
	constructor();
	entries: StringTableEntry[];
	stringToIndex: haxe_IMap<string,number>;
	add(str: string, caseSens: boolean, tag: boolean): number;
	write(bytesData: haxe_io_BytesBuffer): void;
	read(bytesInput: haxe_io_BytesInput): void;
}

export class IdentTable {
	constructor();
	identMap: haxe_IMap<number,number[]>;
	ipToIdentMap: haxe_IMap<number,string>;
	add(compiler: Compiler, ste: string, ip: number): void;
	write(bytesData: haxe_io_BytesBuffer): void;
	read(bytesInput: haxe_io_BytesInput): void;
}

export class Compiler {
	constructor();
	breakLineCount: number;
	inFunction: boolean;
	dsoVersion: number;
	globalFloatTable: number[];
	functionFloatTable: number[];
	currentFloatTable: number[];
	globalStringTable: StringTable;
	functionStringTable: StringTable;
	currentStringTable: StringTable;
	identTable: IdentTable;
	precompileIdent(ident: string): void;
	compileIdent(ident: string, ip: number): number;
	addIntString(value: number): number;
	addFloatString(value: number): number;
	addFloat(value: number): number;
	addString(value: string, caseSens: boolean, tag: boolean): number;
	setTable(target: any, prop: any): void;
	compile(code: string, optimizationLevel?: number): haxe_io_BytesBuffer;
	static stringToNumber(value: string): number;
}

export class DissassemblyData {
	protected constructor();
}

export const enum expr_OpCode {
	FuncDecl = 0,
	CreateObject = 1,
	CreateDataBlock = 2,
	NameObject = 3,
	AddObject = 4,
	EndObject = 5,
	JmpIffNot = 6,
	JmpIfNot = 7,
	JmpIff = 8,
	JmpIf = 9,
	JmpIfNotNP = 10,
	JmpIfNP = 11,
	Jmp = 12,
	Return = 13,
	CmpEQ = 14,
	CmpGT = 15,
	CmpGE = 16,
	CmpLT = 17,
	CmpLE = 18,
	CmpNE = 19,
	Xor = 20,
	Mod = 21,
	BitAnd = 22,
	BitOr = 23,
	Not = 24,
	NotF = 25,
	OnesComplement = 26,
	Shr = 27,
	Shl = 28,
	And = 29,
	Or = 30,
	Add = 31,
	Sub = 32,
	Mul = 33,
	Div = 34,
	Neg = 35,
	SetCurVar = 36,
	SetCurVarCreate = 37,
	SetCurVarArray = 38,
	SetCurVarArrayCreate = 39,
	LoadVarUInt = 40,
	LoadVarFlt = 41,
	LoadVarStr = 42,
	SaveVarUInt = 43,
	SaveVarFlt = 44,
	SaveVarStr = 45,
	SetCurObject = 46,
	SetCurObjectNew = 47,
	SetCurField = 48,
	SetCurFieldArray = 49,
	LoadFieldUInt = 50,
	LoadFieldFlt = 51,
	LoadFieldStr = 52,
	SaveFieldUInt = 53,
	SaveFieldFlt = 54,
	SaveFieldStr = 55,
	StrToUInt = 56,
	StrToFlt = 57,
	StrToNone = 58,
	FltToUInt = 59,
	FltToStr = 60,
	FltToNone = 61,
	UIntToFlt = 62,
	UIntToStr = 63,
	UIntToNone = 64,
	LoadImmedUInt = 65,
	LoadImmedFlt = 66,
	TagToStr = 67,
	LoadImmedStr = 68,
	LoadImmedIdent = 69,
	CallFuncResolve = 70,
	CallFunc = 71,
	ProcessArgs = 72,
	AdvanceStr = 73,
	AdvanceStrAppendChar = 74,
	AdvanceStrComma = 75,
	AdvanceStrNul = 76,
	RewindStr = 77,
	TerminateRewindStr = 78,
	CompareStr = 79,
	Push = 80,
	PushFrame = 81,
	Break = 82,
	Invalid = 83,
}

export type DisassmblyLine = {
	args: DissassemblyData[];
	lineNo: number;
	opCode: expr_OpCode;
	type: any;
}

export class Disassembler {
	constructor();
	globalFloatTable: number[];
	functionFloatTable: number[];
	globalStringTable: string;
	functionStringTable: string;
	identTable: IdentTable;
	dsoVersion: number;
	codeStream: number[];
	lineBreakPairs: number[];
	inFunction: boolean;
	identMap: haxe_IMap<number,string>;
	identMapSize: number;
	opCodeLookup: haxe_IMap<number,string>;
	loadFromBytes(bytes: ArrayBuffer): void;
	load(inData: haxe_io_BytesInput): void;
	getStringTableValue(table: string, offset: number): string;
	getStringTableValueFromRef(table: string, ref: number): string;
	normalizeSTE(steType: any, index: number): number;
	disassembleCode(): DisassmblyLine[];
	writeDisassembly(lines: DisassmblyLine[], outputVerbosity: number): string;
}

export class CompileContext {
	constructor(codeSize: number, lineBreakPairSize: number);
	codeStream: number[];
	lineBreakPairs: number[];
	ip: number;
	continuePoint: number;
	breakPoint: number;
	codeSize: number;
	lineBreakPairSize: number;
}

export class expr_BreakStmt extends expr_Stmt {
	constructor(lineNo: number);
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_ContinueStmt extends expr_Stmt {
	constructor(lineNo: number);
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_Expr extends expr_Stmt {
	constructor(lineNo: number);
	_hx_constructor(lineNo: number): void;
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
	static conversionOp(src: any, dest: any): expr_OpCode;
}

export class expr_ParenthesisExpr extends expr_Expr {
	constructor(expr: expr_Expr);
	_hx_constructor(expr: expr_Expr): void;
	expr: expr_Expr;
	implicit: boolean;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_ReturnStmt extends expr_Stmt {
	constructor(lineNo: number, expr: expr_Expr);
	expr: expr_Expr;
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class Token {
	constructor(type: any, lexeme: string, literal: any, line: number, position: number);
	type: any;
	lexeme: string;
	literal: any;
	line: number;
	position: number;
}

export class expr_AssertStmt extends expr_Stmt {
	constructor(lineNo: number, expr: expr_Expr, message: Token);
	expr: expr_Expr;
	message: Token;
	print(indent: number, isStmt: boolean): string;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_IfStmt extends expr_Stmt {
	constructor(lineNo: number, condition: expr_Expr, body: expr_Stmt[], elseBlock: expr_Stmt[]);
	condition: expr_Expr;
	body: expr_Stmt[];
	elseBlock: expr_Stmt[];
	integer: boolean;
	endifOffset: number;
	elseOffset: number;
	ifStmtList: boolean;
	elseStmtList: boolean;
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_LoopStmt extends expr_Stmt {
	constructor(lineNo: number, condition: expr_Expr, init: expr_Expr, end: expr_Expr, body: expr_Stmt[]);
	_hx_constructor(lineNo: number, condition: expr_Expr, init: expr_Expr, end: expr_Expr, body: expr_Stmt[]): void;
	condition: expr_Expr;
	init: expr_Expr;
	end: expr_Expr;
	body: expr_Stmt[];
	integer: boolean;
	loopBlockStartOffset: number;
	continueOffset: number;
	breakOffset: number;
	isForLoop: boolean;
	isStatementList: boolean;
	isDoWhile: boolean;
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_IterStmt extends expr_Stmt {
	constructor(lineNo: number, init: expr_Expr, collection: expr_Expr, body: expr_Stmt[]);
	init: expr_Expr;
	collection: expr_Expr;
	body: expr_Stmt[];
	isString: boolean;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_BinaryExpr extends expr_Expr {
	constructor(lineNo: number);
	_hx_constructor(lineNo: number): void;
	left: expr_Expr;
	right: expr_Expr;
	op: Token;
	optimized: boolean;
	optimizedExpr: expr_Expr;
	print(indent: number, isStmt: boolean): string;
}

export class expr_FloatBinaryExpr extends expr_BinaryExpr {
	constructor(left: expr_Expr, right: expr_Expr, op: Token);
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	visitStmt(visitor: IASTVisitor): void;
	getPrefferredType(): any;
}

export class expr_IntBinaryExpr extends expr_BinaryExpr {
	constructor(left: expr_Expr, right: expr_Expr, op: Token);
	subType: any;
	operand: expr_OpCode;
	getSubTypeOperand(): void;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	visitStmt(visitor: IASTVisitor): void;
	getPrefferredType(): any;
}

export class expr_StrEqExpr extends expr_BinaryExpr {
	constructor(left: expr_Expr, right: expr_Expr, op: Token);
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	visitStmt(visitor: IASTVisitor): void;
	getPrefferredType(): any;
}

export class expr_StrCatExpr extends expr_BinaryExpr {
	constructor(left: expr_Expr, right: expr_Expr, op: Token);
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	visitStmt(visitor: IASTVisitor): void;
	getPrefferredType(): any;
}

export class expr_CommaCatExpr extends expr_BinaryExpr {
	constructor(left: expr_Expr, right: expr_Expr);
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
}

export class expr_ConditionalExpr extends expr_Expr {
	constructor(condition: expr_Expr, trueExpr: expr_Expr, falseExpr: expr_Expr);
	condition: expr_Expr;
	trueExpr: expr_Expr;
	falseExpr: expr_Expr;
	integer: boolean;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_IntUnaryExpr extends expr_Expr {
	constructor(expr: expr_Expr, op: Token);
	_hx_constructor(expr: expr_Expr, op: Token): void;
	expr: expr_Expr;
	op: Token;
	integer: boolean;
	optimized: boolean;
	optimizedExpr: expr_Expr;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_FloatUnaryExpr extends expr_Expr {
	constructor(expr: expr_Expr, op: Token);
	_hx_constructor(expr: expr_Expr, op: Token): void;
	expr: expr_Expr;
	op: Token;
	optimized: boolean;
	optimizedExpr: expr_Expr;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_VarExpr extends expr_Expr {
	constructor(name: Token, arrayIndex: expr_Expr, type: any);
	name: Token;
	arrayIndex: expr_Expr;
	type: any;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_IntExpr extends expr_Expr {
	constructor(lineNo: number, value: number);
	value: number;
	index: number;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_FloatExpr extends expr_Expr {
	constructor(lineNo: number, value: number);
	value: number;
	index: number;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_StringConstExpr extends expr_Expr {
	constructor(lineNo: number, value: string, tag: boolean);
	value: string;
	tag: boolean;
	fVal: number;
	index: number;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_ConstantExpr extends expr_Expr {
	constructor(name: Token);
	name: Token;
	fVal: number;
	index: number;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_AssignExpr extends expr_Expr {
	constructor(varExpr: expr_VarExpr, expr: expr_Expr);
	varExpr: expr_VarExpr;
	expr: expr_Expr;
	subType: any;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export class expr_AssignOpExpr extends expr_Expr {
	constructor(varExpr: expr_VarExpr, expr: expr_Expr, op: Token);
	varExpr: expr_VarExpr;
	expr: expr_Expr;
	op: Token;
	subType: any;
	operand: expr_OpCode;
	getAssignOpTypeOp(): void;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(visitor: IASTVisitor): void;
}

export const enum expr_FuncCallType {
	FunctionCall = 0,
	MethodCall = 1,
	ParentCall = 2,
}

export class expr_FuncCallExpr extends expr_Expr {
	constructor(name: Token, namespace: Token, args: expr_Expr[], callType: expr_FuncCallType);
	name: Token;
	namespace: Token;
	args: expr_Expr[];
	callType: expr_FuncCallType;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_SlotAccessExpr extends expr_Expr {
	constructor(objectExpr: expr_Expr, arrayExpr: expr_Expr, slotName: Token);
	objectExpr: expr_Expr;
	arrayExpr: expr_Expr;
	slotName: Token;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_SlotAssignExpr extends expr_Expr {
	constructor(objectExpr: expr_Expr, arrayExpr: expr_Expr, slotName: Token, expr: expr_Expr);
	objectExpr: expr_Expr;
	arrayExpr: expr_Expr;
	slotName: Token;
	expr: expr_Expr;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_SlotAssignOpExpr extends expr_Expr {
	constructor(objectExpr: expr_Expr, arrayExpr: expr_Expr, slotName: Token, expr: expr_Expr, op: Token);
	objectExpr: expr_Expr;
	arrayExpr: expr_Expr;
	slotName: Token;
	expr: expr_Expr;
	op: Token;
	subType: any;
	operand: expr_OpCode;
	getAssignOpTypeOp(): void;
	print(indent: number, isStmt: boolean): string;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_ObjectDeclExpr extends expr_Expr {
	constructor(className: expr_Expr, parentObject: Token, objectNameExpr: expr_Expr, args: expr_Expr[], slotDecls: expr_SlotAssignExpr[], subObjects: expr_ObjectDeclExpr[], structDecl: boolean);
	_hx_constructor(className: expr_Expr, parentObject: Token, objectNameExpr: expr_Expr, args: expr_Expr[], slotDecls: expr_SlotAssignExpr[], subObjects: expr_ObjectDeclExpr[], structDecl: boolean): void;
	className: expr_Expr;
	parentObject: Token;
	objectNameExpr: expr_Expr;
	args: expr_Expr[];
	slotDecls: expr_SlotAssignExpr[];
	subObjects: expr_ObjectDeclExpr[];
	structDecl: boolean;
	failOffset: number;
	singleton: boolean;
	print(indent: number, isStmt: boolean): string;
	precompileSubObject(compiler: Compiler, typeReq: any): number;
	compileSubObject(compiler: Compiler, context: CompileContext, typeReq: any, root: boolean): number;
	precompile(compiler: Compiler, typeReq: any): number;
	compile(compiler: Compiler, context: CompileContext, typeReq: any): number;
	getPrefferredType(): any;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_FunctionDeclStmt extends expr_Stmt {
	constructor(functionName: Token, args: expr_VarExpr[], stmts: expr_Stmt[], namespace: Token);
	functionName: Token;
	packageName: Token;
	args: expr_VarExpr[];
	stmts: expr_Stmt[];
	namespace: Token;
	endOffset: number;
	argc: number;
	print(indent: number, isStmt: boolean): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export class expr_InternalNameAccessExpr extends expr_Expr {
	constructor(expr: expr_Expr, nameExpr: expr_Expr);
	expr: expr_Expr;
	nameExpr: expr_Expr;
	recursive: boolean;
	visitStmt(optimizerPass: IASTVisitor): void;
}

export interface IASTVisitor {
	visitStmt(stmt: expr_Stmt): void;
	visitBreakStmt(stmt: expr_BreakStmt): void;
	visitContinueStmt(stmt: expr_ContinueStmt): void;
	visitExpr(expr: expr_Expr): void;
	visitParenthesisExpr(expr: expr_ParenthesisExpr): void;
	visitReturnStmt(stmt: expr_ReturnStmt): void;
	visitAssertStmt(stmt: expr_AssertStmt): void;
	visitIfStmt(stmt: expr_IfStmt): void;
	visitLoopStmt(stmt: expr_LoopStmt): void;
	visitIterStmt(stmt: expr_IterStmt): void;
	visitBinaryExpr(expr: expr_BinaryExpr): void;
	visitFloatBinaryExpr(expr: expr_FloatBinaryExpr): void;
	visitIntBinaryExpr(expr: expr_IntBinaryExpr): void;
	visitStrEqExpr(expr: expr_StrEqExpr): void;
	visitStrCatExpr(expr: expr_StrCatExpr): void;
	visitCommatCatExpr(expr: expr_CommaCatExpr): void;
	visitConditionalExpr(expr: expr_ConditionalExpr): void;
	visitIntUnaryExpr(expr: expr_IntUnaryExpr): void;
	visitFloatUnaryExpr(expr: expr_FloatUnaryExpr): void;
	visitVarExpr(expr: expr_VarExpr): void;
	visitIntExpr(expr: expr_IntExpr): void;
	visitFloatExpr(expr: expr_FloatExpr): void;
	visitStringConstExpr(expr: expr_StringConstExpr): void;
	visitConstantExpr(expr: expr_ConstantExpr): void;
	visitAssignExpr(expr: expr_AssignExpr): void;
	visitAssignOpExpr(expr: expr_AssignOpExpr): void;
	visitFuncCallExpr(expr: expr_FuncCallExpr): void;
	visitSlotAccessExpr(expr: expr_SlotAccessExpr): void;
	visitSlotAssignExpr(expr: expr_SlotAssignExpr): void;
	visitSlotAssignOpExpr(expr: expr_SlotAssignOpExpr): void;
	visitObjectDeclExpr(expr: expr_ObjectDeclExpr): void;
	visitFunctionDeclStmt(stmt: expr_FunctionDeclStmt): void;
	visitInternalNameAccessExpr(expr: expr_InternalNameAccessExpr): void;
}

export class expr_Stmt {
	constructor(lineNo: number);
	_hx_constructor(lineNo: number): void;
	lineNo: number;
	print(indent: number, isStmt: boolean): string;
	printIndent(indent: number): string;
	precompileStmt(compiler: Compiler, loopCount: number): number;
	compileStmt(compiler: Compiler, context: CompileContext): number;
	addBreakCount(compiler: Compiler): void;
	visitStmt(optimizerPass: IASTVisitor): void;
	addBreakLine(ip: number, compiler: Compiler, context: CompileContext): void;
	static _hx_skip_constructor: boolean;
	static recursion: number;
	static precompileBlock(compiler: Compiler, stmts: expr_Stmt[], loopCount: number): number;
	static compileBlock(compiler: Compiler, context: CompileContext, stmts: expr_Stmt[]): number;
	static visitBlock(optimizerPass: IASTVisitor, stmts: expr_Stmt[]): void;
	static printBlock(stmt: expr_Stmt[], indent: number): string;
}

export class JSGenerator {
	constructor(stmts: expr_Stmt[]);
	generate(embedLibrary: boolean): string;
	static bootstrapEmbed(): string;
}

export class Log {
	protected constructor();
	static println(text: string): void;
	static print(text: string): void;
	static setOutputFunction(func: (arg0: string, arg1: boolean) => void): void;
}

export class Parser {
	constructor(tokens: Token[]);
	parse(): expr_Stmt[];
}

export class Scanner {
	constructor(s: string);
	scanTokens(): Token[];
	static unescape(s: string): string;
	static escape(s: string): string;
}

export class Variable {
	constructor(name: string, vm: VM);
	getIntValue(): number;
	getFloatValue(): number;
	getStringValue(): string;
	setIntValue(val: number): void;
	setFloatValue(val: number): void;
	setStringValue(val: string): void;
	resolveArray(arrayIndex: string): Variable;
}

export class StringStack {
	constructor();
	setIntValue(i: number): void;
	setFloatValue(i: number): void;
	clearFunctionOffset(): void;
	setStringValue(s: string): void;
	getSTValue(): string;
	getIntValue(): number;
	getFloatValue(): number;
	advance(): void;
	advanceChar(c: number): void;
	push(): void;
	setLen(newLen: number): void;
	rewind(): void;
	rewindTerminate(): void;
	compare(): boolean;
	pushFrame(): void;
	getArgs(name: string): string[];
}

/**
 * A cell of `haxe.ds.GenericStack`.
 * @see https://haxe.org/manual/std-GenericStack.html
 */
export class haxe_ds_GenericCell<T> {
	constructor(elt: T, next: haxe_ds_GenericCell<T>);
	elt: T;
	next: haxe_ds_GenericCell<T>;
}

/**
 * A stack of elements.
 * This class is generic, which means one type is generated for each type
 * parameter T on static targets. For example:
 * - `new GenericStack<Int>()` generates `GenericStack_Int`
 * - `new GenericStack<String>()` generates `GenericStack_String`
 * The generated name is an implementation detail and should not be relied
 * upon.
 * @see https://haxe.org/manual/std-GenericStack.html
 */
export class haxe_ds_GenericStack<T> {
	/**
	 * Creates a new empty GenericStack.
	 */
	constructor();
	head: haxe_ds_GenericCell<T>;
}

export class console_SimGroup extends console_SimSet {
	constructor();
	addObject(obj: console_SimObject): void;
	removeObject(obj: console_SimObject): void;
	getClassName(): string;
	static install(vm: VM): void;
	static gatherDocs(): {classfuncs: {funcname: string, funcusage: string}[], classname: string, doesextends: boolean, extendsclass: string};
}

export class console_SimObject extends console_ConsoleObject {
	constructor();
	_hx_constructor(): void;
	name: string;
	group: console_SimGroup;
	id: number;
	findObject(name: string): console_SimObject;
	getName(): string;
	deleteObject(): void;
	assignId(id: number): void;
	assignFieldsFrom(obj: console_SimObject): void;
	processArguments(args: string[]): boolean;
	getClassName(): string;
	static setName(vm: VM, thisObj: console_SimObject, args: string[]): void;
	static getName_method(vm: VM, thisObj: console_SimObject, args: string[]): string;
	static getClassName_method(vm: VM, thisObj: console_SimObject, args: string[]): string;
	static getId(vm: VM, thisObj: console_SimObject, args: string[]): number;
	static getGroup(vm: VM, thisObj: console_SimObject, args: string[]): number;
	static delete(vm: VM, thisObj: console_SimObject, args: string[]): void;
	static schedule(vm: VM, thisObj: console_SimObject, args: string[]): number;
	static install(vm: VM): void;
	static gatherDocs(): {classfuncs: {funcname: string, funcusage: string}[], classname: string, doesextends: boolean, extendsclass: string};
}

export type StackFrame = {
	scopeName: string;
	scopeNamespace: console_Namespace;
}

export class ExprEvalState {
	constructor(vm: VM);
	thisObject: console_SimObject;
	thisVariable: Variable;
	globalVars: haxe_IMap<string,Variable>;
	stackVars: haxe_IMap<string,Variable>[];
	stack: StackFrame[];
	vm: VM;
	setCurVarName(name: string): void;
	setCurVarNameCreate(name: string): void;
	getIntVariable(): number;
	getFloatVariable(): number;
	getStringVariable(): string;
	setIntVariable(val: number): void;
	setFloatVariable(val: number): void;
	setStringVariable(val: string): void;
	pushFrame(fnname: string, namespace: console_Namespace): void;
	popFrame(): void;
}

export class console_SimDataBlock extends console_SimObject {
	constructor();
	preload(): boolean;
	getClassName(): string;
	assignClassName(): void;
	static install(vm: VM): void;
	static gatherDocs(): {classfuncs: {funcname: string, funcusage: string}[], classname: string, doesextends: boolean, extendsclass: string};
}

export class VM {
	constructor(async: boolean);
	namespaces: console_Namespace[];
	STR: StringStack;
	floatStack: haxe_ds_GenericStack<number>;
	intStack: haxe_ds_GenericStack<number>;
	evalState: ExprEvalState;
	taggedStrings: string[];
	simObjects: haxe_IMap<string,console_SimObject>;
	dataBlocks: haxe_IMap<string,console_SimDataBlock>;
	idMap: haxe_IMap<number,console_SimObject>;
	rootGroup: console_SimGroup;
	nextSimId: number;
	nextDatablockId: number;
	activePackages: string[];
	codeBlocks: CodeBlock[];
	traceOn: boolean;
	schedules: number[];
	startTime: number;
	isAsync: boolean;
	currentNamespace: console_Namespace;
	findNamespace(name: string): console_Namespace;
	findFunction(namespace: string, name: string): console_NamespaceEntry;
	linkNamespaces(parent: string, child: string): void;
	activatePackage(name: string): void;
	deactivatePackage(name: string): void;
	addConsoleFunction(fnName: string, fnUsage: string, minArgs: number, maxArgs: number, fnType: any): void;
	addJSFunction(func: (arg0: Variable[]) => string, funcName: string, namespace: string, pkg: string): void;
	addConsoleMethod(className: string, fnName: string, fnUsage: string, minArgs: number, maxArgs: number, fnType: any): void;
	findObject(name: string): console_SimObject;
	schedule(time: number, refObject: console_SimObject, args: string[]): number;
	isEventPending(eventId: number): boolean;
	cancelEvent(eventId: number): void;
	callFunction(simObject: console_SimObject, args: string[]): void;
	callFunc(namespaceName: string, funcName: string, funcArgs: string[], callType: string): string;
	newObject(className: string, name: string, isDataBlock: boolean, parentName: string, root: boolean, props: {}, children: Variable[]): Variable;
	resolveIdent(ident: string): Variable;
	slotAssign(obj: Variable, slotName: string, slotArrayIdx: string, valueStr: string): void;
	slotAccess(objstr: string, slotName: string, slotArrayIdx: string): Variable;
	dispose(): void;
	execute(ns: console_NamespaceEntry, args: string[]): string;
}